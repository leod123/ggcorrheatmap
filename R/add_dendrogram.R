#' Add dendrogram to ggplot object.
#'
#' @keywords internal
#'
#' @param plt ggplot object to add dendrogram to.
#' @param dendro Dendrogram segment and node data obtained from the `prepare_dendrogram` function.
#' @param dend_col String specifying colour of dendrogram (used if the colours have not been changed using other options).
#' @param dend_lwd Line width of dendrogram segments (used if not changed using other options).
#' @param dend_lty Line type of dendrogram (used if not changed using other options).
#'
#' @returns A ggplot object with a dendrogram added.
#'
add_dendrogram <- function(plt, dendro, dend_col = "black", dend_lwd = 0.3, dend_lty = 1) {
  x <- y <- xend <- yend <- NULL

  seg <- dendro$seg
  nod <- dendro$nod

  # Draw segments
  # Fill in NAs of col, lwd and lty as using "by_labels_branches_*" in dendextend::set may result in
  # only some segments having specifications and the rest being NA
  seg[["col"]][is.na(seg[["col"]])] <- dend_col
  seg[["lwd"]][is.na(seg[["lwd"]])] <- dend_lwd
  seg[["lty"]][is.na(seg[["lty"]])] <- dend_lty
  seg_colr <- dplyr::pull(dplyr::distinct(seg, col), col)
  # Colours for manual scale
  names(seg_colr) <- seg_colr

  plt <- plt +
    ggnewscale::new_scale_colour() +
    ggplot2::geom_segment(ggplot2::aes(x = x, y = y, xend = xend, yend = yend, colour = col), seg,
                          linewidth = if (all(is.na(seg$lwd))) {dend_lwd}
                          else {seg$lwd},
                          linetype = if (all(is.na(seg$lty))) {dend_lty}
                          else {seg$lty},
                          lineend = "square",
                          show.legend = F) +
    ggplot2::scale_colour_manual(values = seg_colr)

  # Draw nodes
  if (nrow(nod) > 0) {
    # Fill in NAs of pch (19), cex (1) and col (black) so that the nodes are drawn if any one of the parameters is specified
    nod[["pch"]][is.na(nod[["pch"]])] <- 19
    nod[["cex"]][is.na(nod[["cex"]])] <- 1
    nod[["col"]][is.na(nod[["col"]])] <- "black"
    nod_colr <- dplyr::pull(dplyr::distinct(nod, col), col)
    names(nod_colr) <- nod_colr

    plt <- plt +
      ggnewscale::new_scale_colour() +
      ggplot2::geom_point(ggplot2::aes(x = x, y = y, colour = col), nod,
                          size = 1 * nod$cex, shape = nod$pch,
                          show.legend = F) +
      ggplot2::scale_colour_manual(values = nod_colr)
  }

  return(plt)
}


#' Prepare dendrogram by transforming dendrogram segments.
#'
#' @keywords internal
#'
#' @param dendro_in Dendrogram object generated by
#' `some_matrix |> dist() |> hclust() |> as.dendrogram() |> dendextend::as.ggdend()`.
#' @param dend_dim Dimension the dendrogram will be plotted against (rows or columns).
#' @param dend_down Logical indicating if a dendrogram will be plotted along the bottom or top.
#' @param dend_left Logical indicating if a dendrogram will be plotted to the left or to the right.
#' @param dend_dist Distance from heatmap (or annotation) to dendrogram measured in cell size.
#' @param dend_height Scaling parameter of dendrogram height.
#' @param full_plt Logical indicating if the whole heatmap is plotted or not.
#' @param layout The heatmap layout (for reordering rows).
#' @param x_long Data frame containing the values that will be plotted in the heatmap.
#' @param annot_df Data frame containing annotations.
#' @param annot_side Logical specifying which side the annotation will be drawn, analogous to 'dend_down' or 'dend_left'
#' (use the one in the same dimension as the dendrogram).
#' @param annot_pos Vector of the annotation positions along the opposite dimension.
#' @param annot_size Size of annotation cells, specified in heatmap cells (1 being the size of one cell).
#'
#' @return Data frame with dendrogram segment and node parameters.
#'
prepare_dendrogram <- function(dendro_in, dend_dim = c("rows", "cols"),
                               dend_down, dend_left, dend_dist, dend_height, full_plt, layout, x_long,
                               annot_df, annot_side, annot_pos, annot_size) {
  pch <- cex <- x <- y <- NULL

  dend_dim <- dend_dim[1]
  # Segments
  dend_seg <- dendro_in$segments
  # Nodes
  dend_nod  <- dplyr::filter(dendro_in$nodes, !is.na(pch) | !is.na(cex) | !is.na(col))


  dend_seg <- orient_dendrogram(dend_seg, dend_dim, full_plt, layout, dend_left, dend_down)

  # Move dendrogram next to heatmap
  dend_seg <- move_dendrogram(dend_seg, x_long, dend_dim,
                              ifelse(dend_dim == "rows", dend_left, dend_down),
                              dend_dist, annot_df, annot_side, annot_pos, annot_size)

  # Rescale height of dendrogram
  if (dend_height != 1) {
    dend_seg <- scale_dendrogram(dend_seg, dend_dim,
                                 ifelse(dend_dim == "rows", dend_left, dend_down),
                                 dend_height)
  }

  # If nodes have been adjusted in any way, repeat the procedure for nodes
  if (any(!is.na(unlist(dplyr::select(dend_nod, pch, cex, col))))) {
    # Add xend and yend columns to work with transformation functions
    dend_nod <- dplyr::mutate(dend_nod, xend = x, yend = y)

    dend_nod <- orient_dendrogram(dend_nod, dend_dim, full_plt, layout, dend_left, dend_down)

    # Move dendrogram next to heatmap
    dend_nod <- move_dendrogram(dend_nod, x_long, dend_dim,
                                ifelse(dend_dim == "rows", dend_left, dend_down),
                                dend_dist, annot_df, annot_side, annot_pos, annot_size)

    # Rescale height of dendrogram
    if (dend_height != 1) {
      dend_nod <- scale_dendrogram(dend_nod, dend_dim,
                                   ifelse(dend_dim == "rows", dend_left, dend_down),
                                   dend_height)
    }
  }

  return(list("seg" = dend_seg, "nod" = dend_nod))
}


#' Cluster data using hierarchical clustering or use provided clustering.
#'
#' @keywords internal
#'
#' @param cluster_data Either a logical indicating if data should be clustered, or a `hclust` object.
#' @param mat Matrix to cluster.
#' @param cluster_distance Distance metric for clustering.
#' @param cluster_method Clustering method for `hclust`.
#' @param dend_options List or functional sequence specifying `dendextend` functions to use.
#'
#' @returns List containing the dendrogram and clustering objects (or NULL if no clustering).
#'
cluster_dimension <- function(cluster_data, mat, cluster_distance, cluster_method, dend_options = NULL) {
  # Make dendrograms
  if (is.logical(cluster_data) | inherits(cluster_data, "hclust")) {

    clust <- if (is.logical(cluster_data)) {
      hclust(dist(mat, method = cluster_distance), method = cluster_method)
    } else {
      cluster_data
    }

    dendro <- as.dendrogram(clust)

    # Apply dendextend options if any are given
    if (is.list(dend_options)) {
      dendro <- apply_dendextend(dendro, dend_options)
    } else if (inherits(dend_options, "fseq")) {
      dendro <- dend_options(dendro)
    }

    dendro <- dendextend::as.ggdend(dendro)
    dendro$labels$label <- as.character(dendro$labels$label)

    # Add the labels to the segment data frame to later compare final coordinates with plot coordinate system
    dendro$segments$lbl <- dendro$labels[match(dendro$segments$x, dendro$labels$x), "label"]

    return(list("dendro" = dendro, "clust" = clust))

  } else {
    return(NULL)
  }
}


#' Orient a dendrogram.
#'
#' @keywords internal
#'
#' @param dend Dendrogram segments or nodes data frame (containing x, y, xend, yend).
#' @param dim String, rows or cols to know which dimensions dendrogram should be on.
#' @param full_plt Logical indicating if it's for the full layout.
#' @param layout The heatmap layout to take mixed layout into account.
#' @param dend_left Logical indicating if the dendrogram should be placed on the left (only relevant if row dend).
#' @param dend_down Logical indicating if the dendrogram should be placed at the bottom (only relevant if col dend).
#'
#' @returns The input dendrogram data frame but rotated and mirrored to fit the plot.
#'
orient_dendrogram <- function(dend, dim = c("rows", "cols"), full_plt, layout, dend_left, dend_down) {
  y <- yend <- x <- xend <- nx <- nxend <- ny <- nyend <- NULL

  # If mixed layout (treated as full plot) with topleft and bottomright, the row dendrogram must be flipped
  mixed_tl_br <- if (length(layout) == 2) {
    sum(c("tl", "topleft") %in% layout) == 1 & sum(c("br", "bottomright") %in% layout) == 1
  } else {
    FALSE
  }

  dend_new <- if (full_plt) {
    if (dim[1] == "rows" & dend_left) {
      # dend_left row dendrogram
      dplyr::mutate(dend, nx = -y, nxend = -yend,
                    ny = -x * ifelse(mixed_tl_br, -1, 1), nyend = -xend * ifelse(mixed_tl_br, -1, 1))
    } else if (dim[1] == "rows" & !dend_left) {
      # right row dendrogram
      dplyr::mutate(dend, nx = y, nxend = yend,
                    ny = -x * ifelse(mixed_tl_br, -1, 1), nyend = -xend * ifelse(mixed_tl_br, -1, 1))
    } else if (dim[1] == "cols" & dend_down) {
      # bottom column dendrogram
      dplyr::mutate(dend, nx = x, nxend = xend, ny = -y, nyend = -yend)
    } else if (dim[1] == "cols" & !dend_down) {
      # top column dendrogram
      dplyr::mutate(dend, nx = x, nxend = xend, ny = y, nyend = yend)
    }
  } else {
    if (dend_left & !dend_down) {
      # top left
      if (dim[1] == "rows") {
        dplyr::mutate(dend, nx = -y, nxend = -yend, ny = x, nyend = xend)
      } else if (dim[1] == "cols") {
        dplyr::mutate(dend, nx = x, nxend = xend, ny = y, nyend = yend)
      }
    } else if (!dend_left & !dend_down) {
      # top right
      if (dim[1] == "rows") {
        dplyr::mutate(dend, nx = y, nxend = yend, ny = -x, nyend = -xend)
      } else if (dim[1] == "cols") {
        dplyr::mutate(dend, nx = x, nxend = xend, ny = y, nyend = yend)
      }
    } else if (!dend_left & dend_down) {
      # bottom right
      if (dim[1] == "rows") {
        dplyr::mutate(dend, nx = y, nxend = yend, ny = x, nyend = xend)
      } else if (dim[1] == "cols") {
        dplyr::mutate(dend, nx = x, nxend = xend, ny = -y, nyend = -yend)
      }
    } else if (dend_left & dend_down) {
      # bottom left
      if (dim[1] == "rows") {
        dplyr::mutate(dend, nx = -y, nxend = -yend, ny = -x, nyend = -xend)
      } else if (dim[1] == "cols") {
        dplyr::mutate(dend, nx = x, nxend = xend, ny = -y, nyend = -yend)
      }
    }
  }

  dend_new <- dplyr::select(dend_new, -x, -xend, -y, -yend)
  dend_new <- dplyr::rename(dend_new, x = nx, xend = nxend, y = ny, yend = nyend)

  return(dend_new)
}


#' Move coordinates of dendrogram to edges of heatmap
#'
#' @description
#' Move coordinates of dendrogram by calculating distance it has to move to end up at the desired edges of the heatmap
#'
#' @keywords internal
#'
#' @param dend_seg Data frame containing dendrogram segments, attained from `dendextend::as.ggdend()`
#' @param x_long Long format data frame with the values
#' @param dend_dim Character specifying whether the dendrogram is linked to rows or columns in the heatmap
#' @param dend_side Logical specifying dendrogram position. TRUE is left of the heatmap if row dendrogram, bottom of heatmap if column dendrogram
#' @param dend_dist Distance from heatmap (or annotation) to dendrogram in cell size.
#' @param annot_df Data frame with annotations for checking that annotations exist as well as their size
#' @param annot_side Logical specifying annotation position, analogous to `dend_side`
#' @param annot_pos Numeric vector of annotation coordinates (x coordinates for row annotations, y for column annotations)
#' @param annot_size Numeric of length 1, the specified size (width or height) of annotation cells
#'
#' @return Data frame with updated dendrogram coordinates
#'
move_dendrogram <- function(dend_seg, x_long, dend_dim = c("rows", "cols"), dend_side, dend_dist,
                            annot_df, annot_side, annot_pos, annot_size) {

  if (dend_dim[1] == "rows") {
    xmove <- ifelse(
      dend_side,
      # Dendrograms on the left. If there is no annotation start at 0.5 (center of leftmost cell is at 1, move half a cell left)
      # If there is annotation, need to take annotation width into account (annot_size)
      ifelse(    # Annotation left of plot or not
        is.data.frame(annot_df) & annot_side,
        min(annot_pos) - 0.5 * annot_size - max(c(dend_seg$x, dend_seg$xend)),
        0.5 - max(c(dend_seg$x, dend_seg$xend))
      ) - dend_dist,
      ifelse(    # Dendrograms on the right, annotation right of plot or not
        is.data.frame(annot_df) & !annot_side,
        max(annot_pos) + 0.5 * annot_size - min(c(dend_seg$x, dend_seg$xend)),
        length(unique(x_long$col)) + 0.5 - min(c(dend_seg$x, dend_seg$xend))
      ) + dend_dist
    )

    ymove <- length(unique(x_long$row)) - max(c(dend_seg$y, dend_seg$yend))

  } else {

    xmove <- 1 - min(c(dend_seg$x, dend_seg$xend))

    ymove <- ifelse(
      # Dendrogram above or below heatmap
      dend_side,
      ifelse(    # Dendrogram below heatmap, annotation or not
        is.data.frame(annot_df) & annot_side,
        min(annot_pos) - 0.5 * annot_size - max(c(dend_seg$y, dend_seg$yend)),
        0.5 - max(c(dend_seg$y, dend_seg$yend))
      ) - dend_dist,
      ifelse(    # Dendrogram above heatmap, annotation or not
        is.data.frame(annot_df) & !annot_side,
        max(annot_pos) + 0.5 * annot_size - min(c(dend_seg$y, dend_seg$yend)),
        length(unique(x_long$row)) + 0.5 - min(c(dend_seg$y, dend_seg$yend))
      ) + dend_dist
    )
  }

  dend_seg[, c("x", "xend")] <- dend_seg[, c("x", "xend")] + xmove
  dend_seg[, c("y", "yend")] <- dend_seg[, c("y", "yend")] + ymove

  return(dend_seg)
}


#' Scale height of dendrogram.
#'
#' @keywords internal
#'
#' @param dend_seg Data frame containing dendrogram segments in format obtained from `dendextend`.
#' @param dend_dim Dimension to draw dendrogram along (rows or columns).
#' @param dend_side Logical indicating which side to draw dendrogram on.
#' If row dendrogram TRUE is left. If column dendrogram TRUE is down.
#' @param dend_height Scaling parameter for dendrogram height (1 is no scaling).
#'
#' @return Data frame containing coordinates for dendrogram segments (and any colour, linewidth, line type parameters)
#'
scale_dendrogram <- function(dend_seg, dend_dim = c("rows", "cols"), dend_side, dend_height) {
  xend <- x <- yend <- y <- NULL

  if (dend_dim[1] == "rows") {
    dend_seg_out <- dplyr::mutate(
      dend_seg,
      # Move horizontal segments by scaling the distance from the points touching the heatmap
      x = ifelse(dend_side, max(xend), min(xend)) +
        (x - ifelse(dend_side, max(xend), min(xend))) * dend_height,
      xend = ifelse(dend_side, max(xend), min(xend)) +
        (xend - ifelse(dend_side, max(xend), min(xend))) * dend_height
    )
  } else {
    dend_seg_out <- dplyr::mutate(
      dend_seg,
      y = ifelse(!dend_side, min(yend), max(yend)) +
        (y - ifelse(!dend_side, min(yend), max(yend))) * dend_height,
      yend = ifelse(!dend_side, min(yend), max(yend)) +
        (yend - ifelse(!dend_side, min(yend), max(yend))) * dend_height
    )
  }

  return(dend_seg_out)
}

#' Check that dendrograms are positioned correctly
#'
#' @keywords internal
#'
#' @param dat Long format data for plotting.
#' @param dend_dim Dimension to which the dendrogram is added. These are used to directly get the columns
#' in the long data and thus need to be "row" or "col".
#' @param dendro The dendrogram segments and nodes list.
#'
#' @returns `dendro` is returned as is if the positions are correct. Otherwise there is an error.
#'
check_dendrogram_pos <- function(dat, dend_dim = c("row", "col"), dendro) {
  lbl <- NULL

  coord_dim <- if (dend_dim[1] == "row") "y" else if (dend_dim[1] == "col") "x" else NA

  seg <- dendro$seg
  dend_lab <- dplyr::select(seg, lbl, !!coord_dim)
  dend_lab <- dplyr::filter(dend_lab, !is.na(lbl))
  # Take only distinct rows, in case a segment ends up on the same coordinate as the lowest node
  dend_lab <- dplyr::distinct(dend_lab, lbl, !!coord_dim, .keep_all = T)

  # Add plot coordinates of labels
  dend_lab$plt_coord <- seq_along(levels(dat[[dend_dim[1]]]))[match(dend_lab$lbl, levels(dat[[dend_dim[1]]]))]

  # Check if same coordinates (within tolerance)
  if (!all(dplyr::near(dend_lab[[coord_dim]], dend_lab[["plt_coord"]]))) {
    cli::cli_warn("Something went wrong with dendrogram positioning! The leaves may be in the wrong coordinates. Please inform the author.")
  }

  return(dendro)
}


#' Successively apply dendextend functions to a dendrogram.
#'
#' @keywords internal
#'
#' @param dendro Dendrogram object obtained from `stats::as.dendrogram`.
#' @param dend_list List specifying dendextend functions to apply. For usage see the details of `gghm`.
#'
#' @returns A dendrogram object modified with dendextend functions.
#'
apply_dendextend <- function(dendro, dend_list) {
  # Go through options list and update the dendrogram successively with do.call
  # Use append() to make named list of input arguments
  for (i in seq_along(dend_list)) {
    # Make a temporary function by calling the provided function from dendextend
    dend_fun <- do.call(`::`, list("dendextend", names(dend_list)[i]))
    dendro <- do.call(dend_fun, append(list(dendro), dend_list[[i]]))
  }

  return(dendro)
}


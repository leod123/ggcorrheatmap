#' Add dendrogram to ggplot object.
#'
#' @keywords internal
#'
#' @param ggp ggplot object to add dendrogram to.
#' @param dend_seg Dendrogram segment data obtained from the `prepare_dendrogram` function.
#' @param dend_col String specifying colour of dendrogram (used if the colours have not been changed using other options).
#' @param dend_lwd Line width of dendrogram segments (used if not changed using other options).
#' @param dend_lty Line type of dendrogram (used if not changed using other options).
#'
#' @returns A ggplot object with a dendrogram added.
#'
add_dendrogram <- function(ggp, dend_seg, dend_col = "black", dend_lwd = 0.3, dend_lty = 1) {
  if (all(is.na(dend_seg$col))) {
    # If the segment colours have not been changed, use the same colour for all segments
    ggp <- ggp +
      ggplot2::geom_segment(ggplot2::aes(x = x, y = y, xend = xend, yend = yend), dend_seg,
                            colour = dend_col,
                            # Line width and type, same for all if not otherwise specified
                            linewidth = if (all(is.na(dend_seg$lwd))) {dend_lwd}
                            else {dend_seg$lwd},
                            linetype = if (all(is.na(dend_seg$lty))) {dend_lty}
                            else {dend_seg$lty})
  } else {
    seg_colr <- dplyr::pull(dplyr::distinct(dend_seg, col), col)
    names(seg_colr) <- seg_colr
    ggp <- ggp +
      ggnewscale::new_scale_colour() +
      ggplot2::geom_segment(ggplot2::aes(x = x, y = y, xend = xend, yend = yend, colour = col), dend_seg,
                            linewidth = if (all(is.na(dend_seg$lwd))) {dend_lwd}
                            else {dend_seg$lwd},
                            linetype = if (all(is.na(dend_seg$lty))) {dend_lty}
                            else {dend_seg$lty},
                            show.legend = F) +
      ggplot2::scale_colour_manual(values = seg_colr)
  }

  return(ggp)
}


#' Prepare dendrogram by transforming dendrogram segments.
#'
#' @keywords internal
#'
#' @param dendro_in Dendrogram object generated by
#' `some_matrix |> dist() |> hclust() |> as.dendrogram() |> dendextend::as.ggdend()`.
#' @param dend_dim Dimension the dendrogram will be plotted against (rows or columns).
#' @param dend_down Logical indicating if a dendrogram will be plotted along the bottom or top.
#' @param dend_left Logical indicating if a dendrogram will be plotted to the left or to the right.
#' @param dend_height Scaling parameter of dendrogram height.
#' @param full_plt Logical indicating if the whole heatmap is plotted or not.
#' @param cor_long Data frame containing the correlations that will be plotted in the heatmap.
#' @param annot_df Data frame containing annotations.
#' @param annot Logical indicating if annotations will be drawn for the specified dendrogram dimension.
#' @param annot_side Logical specifying which side the annotation will be drawn, analogous to 'dend_down' or 'dend_left'
#' (use the one in the same dimension as the dendrogram).
#' @param annot_pos Vector of the annotation positions along the opposite dimension.
#' @param annot_size Size of annotation cells, specified in heatmap cells (1 being the size of one cell).
#'
#' @return Data frame with dendrogram segment parameters.
#'
prepare_dendrogram <- function(dendro_in, dend_dim = c("rows", "cols"),
                               dend_down, dend_left, dend_height, full_plt, cor_long,
                               annot_df, annot, annot_side, annot_pos, annot_size) {

  dend_dim <- dend_dim[1]
  dend_seg <- dendro_in$segments

  # Rotate dendrogram to face heatmap
  rot_angle <- if (dend_dim == "rows") {
    # If row dendrogram rotate 90 or -90 degrees
    ifelse(dend_left, pi/2, -pi/2)
  } else {
    # Column dendrogram, no rotation or 180 degrees
    ifelse(!dend_down, 0, pi)
  }
  dend_seg[, c("x", "y")] <- as.data.frame(t(rotate(t(dend_seg[, c("x", "y")]), angle = rot_angle)))
  dend_seg[, c("xend", "yend")] <- as.data.frame(t(rotate(t(dend_seg[, c("xend", "yend")]), angle = rot_angle)))

  # If needed mirror the dendrogram around the middle if the rotation caused it to not line up with the correct rows
  # Since all triangular layouts restrict the possible dendrogram positions and change the row and column orders, need layout-specific conditions
  if (dend_dim == "rows") {
    if ((!dend_left & full_plt) | (dend_down & dend_left & !full_plt) | (!dend_down & !dend_left & !full_plt)) {
      dend_seg <- mirror_dendrogram(dend_seg, dend_dim)
    }
  } else if (dend_dim == "cols") {
    if ((!dend_down & full_plt) | (!dend_down & !dend_left & !full_plt) | (dend_down & dend_left & !full_plt)) {
      dend_seg <- mirror_dendrogram(dend_seg, dend_dim)
    }
  }

  # Move dendrogram next to heatmap
  dend_seg <- move_dendrogram(dend_seg, cor_long, dend_dim,
                              ifelse(dend_dim == "rows", dend_left, dend_down),
                              annot_df, annot, annot_side, annot_pos, annot_size)

  # Rescale height of dendrogram
  if (dend_height != 1) {
    dend_seg <- scale_dendrogram(dend_seg, dend_dim,
                                 ifelse(dend_dim == "rows", dend_left, dend_down),
                                 dend_height)
  }

  return(dend_seg)
}


#' Cluster data using hierarchical clustering or use provided clustering.
#'
#' @keywords internal
#'
#' @param cluster_data Either a logical indicating if data should be clustered, or a `hclust` object.
#' @param mat Matrix to cluster.
#' @param cluster_distance Distance metric for clustering.
#' @param cluster_method Clustering method for `hclust`.
#' @param dend_options List or functional sequence specifying `dendextend` functions to use.
#'
#' @returns List containing the dendrogram and clustering objects (or NULL if no clustering).
#'
cluster_dimension <- function(cluster_data, mat, cluster_distance, cluster_method, dend_options = NULL) {
  # Make dendrograms
  if (is.logical(cluster_data) | inherits(cluster_data, "hclust")) {

    clust <- if (is.logical(cluster_data)) {
      hclust(dist(mat, method = cluster_distance), method = cluster_method)
    } else {
      cluster_data
    }

    dendro <- as.dendrogram(clust)

    # Apply dendextend options if any are given
    if (is.list(dend_options)) {
      dendro <- apply_dendextend(dendro, dend_options)
    } else if (inherits(dend_options, "fseq")) {
      dendro <- dend_options(dendro)
    }

    dendro <- dendextend::as.ggdend(dendro)
    dendro$labels$label <- as.character(dendro$labels$label)

    # Add the labels to the segment data frame to later compare final coordinates with plot coordinate system
    dendro$segments$lbl <- dendro$labels[match(dendro$segments$x, dendro$labels$x), "label"]

    return(list("dendro" = dendro, "clust" = clust))

  } else {
    return(NULL)
  }
}


#' Rotate cartesian coordinates around 0
#'
#' @param x Matrix of coordinates to rotate. Should be either a numeric vector of length 2, or a matrix with two rows (for rotating multiple coordinates at once)
#' @param angle The angle to rotate by. Default is radians.
#' @param radians Logical indicating if the given angle is in radians. If FALSE, degrees are used.
#'
#' @return A numeric matrix of rotated coordinates. Contains two rows (x and y coordinates) and one column per input coordinate.
#' @export
#'
#' @examples
#' rotate(c(1, 2), pi)
#'
#' rotate(matrix(c(1, 2,
#'                 3, 4),
#'                 byrow = FALSE, nrow = 2),
#'        angle = 90, radians = FALSE)
rotate <- function(x, angle, radians = T) {
  angle <- ifelse(radians, angle, angle * pi / 180)

  matrix(c(cos(angle), -sin(angle), sin(angle), cos(angle)), nrow = 2, ncol = 2, byrow = T) %*% x
}


#' Mirror coordinates of dendrogram around its middle point
#'
#' @description
#' Mirror a dendrogram around an axis parallel to the height, located in its middle point
#'
#' @keywords internal
#'
#' @param dend_seg Data frame containing dendrogram segments, attained from `dendextend::as.ggdend()`
#' @param dend_dim Character specifying whether the dendrogram is linked to rows or columns in the heatmap
#'
#' @return Dendrogram segment coordinates dataframe, with the specified dimension mirrored
#'
mirror_dendrogram <- function(dend_seg, dend_dim = c("rows", "cols")) {

  stopifnot(dend_dim[1] %in% c("rows", "cols"))

  if (dend_dim[1] == "rows") {

    dend_middle <- (max(c(dend_seg$y, dend_seg$yend)) - min(c(dend_seg$y, dend_seg$yend))) / 2
    dend_seg$y <- dend_seg$y - 2 * (dend_seg$y - dend_middle)
    dend_seg$yend <- dend_seg$yend - 2 * (dend_seg$yend - dend_middle)

  } else {

    dend_middle <- (max(c(dend_seg$x, dend_seg$xend)) - min(c(dend_seg$x, dend_seg$xend))) / 2
    dend_seg$x <- dend_seg$x - 2 * (dend_seg$x - dend_middle)
    dend_seg$xend <- dend_seg$xend - 2 * (dend_seg$xend - dend_middle)

  }

  return(dend_seg)
}


#' Move coordinates of dendrogram to edges of heatmap
#'
#' @description
#' Move coordinates of dendrogram by calculating distance it has to move to end up at the desired edges of the heatmap
#'
#' @keywords internal
#'
#' @param dend_seg Data frame containing dendrogram segments, attained from `dendextend::as.ggdend()`
#' @param cor_long Long format data frame with the correlations
#' @param dend_dim Character specifying whether the dendrogram is linked to rows or columns in the heatmap
#' @param dend_side Logical specifying dendrogram position. TRUE is left of the heatmap if row dendrogram, bottom of heatmap if column dendrogram
#' @param annot_df Data frame with annotations for checking that annotations exist as well as their size
#' @param annot Logical indicating if annotations are intended to be drawn or not
#' @param annot_side Logical specifying annotation position, analogous to `dend_side`
#' @param annot_pos Numeric vector of annotation coordinates (x coordinates for row annotations, y for column annotations)
#' @param annot_size Numeric of length 1, the specified size (width or height) of annotation cells
#'
#' @return Data frame with updated dendrogram coordinates
#'
move_dendrogram <- function(dend_seg, cor_long, dend_dim = c("rows", "cols"), dend_side,
                            annot_df, annot, annot_side, annot_pos, annot_size) {

  # Check that dendrogram dimension (rows or columns) is specified properly
  stopifnot(dend_dim[1] %in% c("rows", "cols"))

  if (dend_dim[1] == "rows") {

    xmove <- ifelse(
      # Dendrogram on left or right side
      dend_side,
      ifelse(    # Annotation left of rows or not
        is.data.frame(annot_df) & annot & annot_side,
        min(annot_pos) - 0.5 * annot_size - max(c(dend_seg$x, dend_seg$xend)),
        0.5 - max(c(dend_seg$x, dend_seg$xend))
      ),
      ifelse(    # Annotation right of rows or not
        is.data.frame(annot_df) & annot & !annot_side,
        max(annot_pos) + 0.5 * annot_size - min(c(dend_seg$x, dend_seg$xend)),
        length(unique(cor_long$col)) + 0.5 - min(c(dend_seg$x, dend_seg$xend))
      )
    )

    ymove <- length(unique(cor_long$row)) - max(c(dend_seg$y, dend_seg$yend))

  } else {

    xmove <- 1 - min(c(dend_seg$x, dend_seg$xend))

    ymove <- ifelse(
      # Dendrogram above or below heatmap
      dend_side,
      ifelse(    # Annotation below heatmap
        is.data.frame(annot_df) & annot & annot_side,
        min(annot_pos) - 0.5 * annot_size - max(c(dend_seg$y, dend_seg$yend)),
        0.5 - max(c(dend_seg$y, dend_seg$yend))
      ),
      ifelse(    # Annotation above heatmap
        is.data.frame(annot_df) & annot & !annot_side,
        max(annot_pos) + 0.5 * annot_size - min(c(dend_seg$y, dend_seg$yend)),
        length(unique(cor_long$row)) + 0.5 - min(c(dend_seg$y, dend_seg$yend))
      )
    )
  }

  dend_seg[, c("x", "xend")] <- dend_seg[, c("x", "xend")] + xmove
  dend_seg[, c("y", "yend")] <- dend_seg[, c("y", "yend")] + ymove

  return(dend_seg)
}


#' Scale height of dendrogram.
#'
#' @keywords internal
#'
#' @param dend_seg Data frame containing dendrogram segments in format obtained from `dendextend`.
#' @param dend_dim Dimension to draw dendrogram along (rows or columns).
#' @param dend_side Logical indicating which side to draw dendrogram on.
#' If row dendrogram TRUE is left. If column dendrogram TRUE is down.
#' @param dend_height Scaling parameter for dendrogram height (1 is no scaling).
#'
#' @return Data frame containing coordinates for dendrogram segments (and any colour, linewidth, line type parameters)
#'
scale_dendrogram <- function(dend_seg, dend_dim = c("rows", "cols"), dend_side, dend_height) {

  stopifnot(dend_dim[1] %in% c("rows", "cols"))

  if (dend_dim[1] == "rows") {
    dend_seg_out <- dplyr::mutate(
      dend_seg,
      # Move horizontal segments by scaling the distance from the points touching the heatmap
      x = ifelse(dend_side, max(xend), min(xend)) +
        (x - ifelse(dend_side, max(xend), min(xend))) * dend_height,
      xend = ifelse(dend_side, max(xend), min(xend)) +
        (xend - ifelse(dend_side, max(xend), min(xend))) * dend_height
    )
  } else {
    dend_seg_out <- dplyr::mutate(
      dend_seg,
      y = ifelse(!dend_side, min(yend), max(yend)) +
        (y - ifelse(!dend_side, min(yend), max(yend))) * dend_height,
      yend = ifelse(!dend_side, min(yend), max(yend)) +
        (yend - ifelse(!dend_side, min(yend), max(yend))) * dend_height
    )
  }

  return(dend_seg_out)
}


#' Check that dendrograms are positioned correctly
#'
#' @keywords internal
#'
#' @param dat Long format data for plotting.
#' @param dend_dim Dimension to which the dendrogram is added.
#' @param dend The dendrogram segments data frame.
#'
#' @returns `dend` is returned as is if the positions are correct. Otherwise there is an error.
#'
check_dendrogram_pos <- function(dat, dend_dim = c("row", "col"), dend) {
  coord_dim <- if (dend_dim[1] == "row") "y" else if (dend_dim[1] == "col") "x" else NA
  stopifnot(coord_dim %in% c("x", "y"))

  dend_lab <- dplyr::select(dend, lbl, coord_dim)
  dend_lab <- dplyr::filter(dend_lab, !is.na(lbl))
  # Take only distinct rows, in case a segment ends up on the same coordinate as the lowest node
  # Since they are originally float numbers, they may differ by a very small amount. Compare rounded versions
  dend_lab$coord_rounded <- round(dend_lab[[coord_dim]], 0)
  dend_lab <- dplyr::distinct(dend_lab, lbl, coord_rounded, .keep_all = T)

  # Add plot coordinates of labels
  dend_lab$plt_coord <- seq_along(levels(dat[[dend_dim[1]]]))[match(dend_lab$lbl, levels(dat[[dend_dim[1]]]))]

  # Check if same coordinates (within tolerance)
  stopifnot(all(dplyr::near(dend_lab[[coord_dim]], dend_lab[["plt_coord"]])))

  return(dend)
}


#' Successively apply dendextend functions to a dendrogram.
#'
#' @keywords internal
#'
#' @param dendro Dendrogram object obtained from `stats::as.dendrogram`.
#' @param dend_list List specifying dendextend functions to apply. For usage see the details of `gg_corr_heatmap`.
#'
#' @returns A dendrogram object modified with dendextend functions.
#'
apply_dendextend <- function(dendro, dend_list) {
  # Go through options list and update the dendrogram successively with do.call
  # Use append() to make named list of input arguments
  for (i in seq_along(dend_list)) {
    # Make a temporary function by calling the provided function from dendextend
    dend_fun <- do.call(`::`, list("dendextend", names(dend_list)[i]))
    dendro <- do.call(dend_fun, append(list(dendro), dend_list[[i]]))
  }

  return(dendro)
}


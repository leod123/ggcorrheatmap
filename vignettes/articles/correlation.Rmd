---
title: "Correlation heatmaps"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(ggcorrheatmap)
library(ggplot2)
suppressPackageStartupMessages(library(dplyr))
```

Correlation heatmaps can be made easily using the `ggcorrhm` function. `ggcorrhm` is a wrapper for (and shares most of its arguments with) `gghm` and calculates the correlation matrix for the input passed to `gghm`. If one matrix is provided the column-column correlations are plotted. If two matrices are provided, the correlations between the columns in the two matrices are plotted. Using the `cor_method` and `cor_use` different `method` and `use` arguments can be passed to `stats::cor`.

```{r symmetric correlation heatmap}
ggcorrhm(mtcars)
```

```{r asymmetric correlation heatmap, fig.height=3, fig.width=8}
ggcorrhm(iris[1:nrow(mtcars), -5], mtcars)
```

# Changing the colours

`ggcorrhm` sets the fill scale to use `ggplot2::scale_fill_gradient2()` with limits set to [-1, 1]. The colours can be changed using the `high`, `mid` and `low` arguments. If a discrete scale is desired, `bins` can be used to bin the scale. The scale can be overwritten completely by adding a `ggplot2` scale to the plot.

For symmetric matrices, the axis names are drawn on the diagonal. The `names_diag`, `names_x` and `names_y` arguments control where names should be drawn.

```{r changing colour, out.width='50%', fig.show='hold'}
ggcorrhm(mtcars, names_diag = FALSE, names_x = TRUE, names_y = TRUE,
         high = "green", low = "magenta", mid = "yellow", bins = 6)

ggcorrhm(mtcars) + scale_fill_continuous()
```

# Changing the layout

For symmetric heatmaps, the `layout` argument can be used to get triangular layouts. The possible layouts are full matrix, top left, top right, bottom left, and bottom right.

```{r heatmap layouts}
ggcorrhm(mtcars, layout = "topleft")
# The diagonal is displayed by default but can be hidden using the `include_diag` argument
# Layouts can be specified by the first letters e.g. br, tl, f (for full), w (whole, same as full)
ggcorrhm(mtcars, layout = "br", include_diag = FALSE)
```

# Label customisation

The looks of the names displayed in the diagonal of symmetric matrices can be adjusted with the `names_diag_params` argument, which takes a named list of parameters to pass to `ggplot2::geom_text`. For names displayed on the x and y axes, use `ggplot2::theme` on the generated plot object to change the appearance.

```{r, fig.width=5, fig.height=4, fig.show='hold', out.width='50%'}
ggcorrhm(mtcars, layout = "bl", show_legend = FALSE, include_diag = FALSE,
         names_diag_param = list(
           angle = 45, vjust = 0.5, hjust = 0.5, colour = "magenta"
         ))
# Also take vectorised input
set.seed(123)
ggcorrhm(mtcars, layout = "br", include_diag = FALSE,
         names_diag_param = list(
           angle = c(0, rep(-45, 9), 90),
           hjust = c(rep(0.7, 10), 0.3),
           colour = sample(c("red", "green", "blue"), 11, TRUE)
         ))
```

# Legend position

The legend can be moved around by adding to the theme of the output plot using `ggplot2::theme`. Use the `legend.position.inside` argument to move the legend to the plotting area to make use of the empty space of triangular layouts.

```{r legend position, fig.width=5, fig.height=4, fig.show='hold', out.width='50%'}
ggcorrhm(mtcars) + theme(legend.position = "top")
ggcorrhm(mtcars, layout = "br") +
  theme(legend.position = "inside", legend.position.inside = c(0.2, 0.7))
```

# Clustering and annotation

Just like with `gghm`, the heatmap can be clustered and annotated. Triangular layouts limit the positions of annotation and dendrograms to the non-empty sides of the heatmap.

```{r clustering and annotation}
set.seed(123)
# Make a correlation heatmap with a triangular layout, annotations and clustering
row_annot <- data.frame(.names = colnames(mtcars),
                        annot1 = sample(letters[1:3], ncol(mtcars), TRUE),
                        annot2 = rnorm(ncol(mtcars)))
ggcorrhm(mtcars, layout = "tl", cluster_rows = TRUE, cluster_cols = TRUE,
         dend_rows = FALSE, annot_rows_df = row_annot, annot_rows_label_side = "top")
```

# Cell text

The `cell_labels` argument labels cells with their values. The `cell_label_col`, `cell_label_size` and `cell_label_digits` arguments control the text colour, size and the number of displayed digits, respectively.

```{r cell labels, fig.show='hold', out.width='50%'}
ggcorrhm(mtcars, layout = "br", cell_labels = TRUE)
set.seed(123)
ggcorrhm(mtcars, layout = "br", cell_labels = TRUE,
         cell_label_digits = 1,
         # cell_label_col and cell_label_size take one value or
         # one for each cell being labelled (not counting names on the diagonal)
         cell_label_col = "white",
         cell_label_size = sample(2:4, 55, TRUE))
```

# Cell shape

Correlation heatmaps are sometimes plotted with circles. Using the `mode` argument allows for custom cell shapes. The shape size is set to scale with the absolute value of the correlation. `size_scale` can be provided to overwrite this behaviour. Setting `mode` to 'text' writes the values in empty cells, with the text colour scaling with the value.

```{r cell shape, fig.show='hold', out.width='50%'}
# If numeric, the R pch symbols are used, meaning 21 produces circles.
# Any character value results in normal heatmap cells
ggcorrhm(mtcars, mode = 21) + labs(title = "mode = 21")
# It is also possible to use shapes other than circles. Only 21-25 support filling.
# Change the size range using the size_range argument
ggcorrhm(mtcars, mode = 23, size_range = c(1, 15)) +
  labs(title = "mode = 23")
```

It's also possible to draw mixed layouts by providing two values to `layout` and `mode`. See the [mixed layouts](mixed.html) vignette for more details.

```{r}
# Default modes for mixed layouts is 'heatmap' and 'text'
ggcorrhm(mtcars, layout = c("tr", "bl"))
```

# P-values

P-values can be calculated by setting the `p_values` argument to `TRUE`. The values can be adjusted for multiple testing by passing a string specifying the adjustment method to `p_adjust`. If the correlation matrix is symmetric, the diagonal is excluded and only half of the off-diagonal values are used for the adjustment. The calculated p-values will be included in the data if `return_data` is `TRUE`.

By default, cells are marked with asterisks if `p_values` is `TRUE`. The `p_thresholds` argument controls the p-value thresholds. `p_thresholds` must be a named numeric vector where the values specify the thresholds (in ascending order) and the names are the symbols to use when an adjusted p-value is below each threshold. `stats::symnum` is used to convert p-values and the last value of `p_thresholds` must be 1 (or any higher number) to set the upper bound. By default, `p_thresholds` is set to be `c("***" = 0.001, "**" = 0.01, "*" = 0.05", 1)`. As can be seen, 1 is left unnamed so that any p-values between 0.05 and 1 are unmarked.

If `cell_labels` is `TRUE` (so that correlation values are written in the cells), the symbols from `p_thresholds` are added at the end of the correlation values. It is also possible to write out the p-values instead of correlation values by setting both `cell_labels` and `cell_label_p` to TRUE.

```{r}
# P-value symbols added to the plot
ggcorrhm(mtcars, p_values = TRUE, p_adjust = "bonferroni", cell_label_size = 6)
# With correlation text
ggcorrhm(mtcars, p_values = TRUE, p_adjust = "bonferroni", cell_labels = TRUE)
# Changing the symbols
ggcorrhm(mtcars, p_values = TRUE, p_adjust = "bonferroni",
         p_thresholds = c("+" = 0.01, "*" = 0.05, "ns" = 1))
```

By returning the data and using `ggplot2` functions it is possible to be more creative with the p-value marking than `ggcorrhm` allows out of the box.

```{r}
p <- ggcorrhm(mtcars, p_values = TRUE, p_thresholds = NULL,
              p_adjust = "bonferroni", return_data = TRUE,
              layout = "br", include_diag = TRUE)
p$plot_data <- mutate(p$plot_data,
                      p_lty = case_when(p_adj < 0.05 ~ 1, TRUE ~ 3),
                      p_lwd = case_when(p_adj < 0.05 ~ 1, TRUE ~ 0.5),
                      p_size = -log10(p_adj))
ggcorrhm(mtcars, border_lty = p$plot_data$p_lty, border_lwd = p$plot_data$p_lwd,
         layout = "br", include_diag = TRUE) +
  geom_point(aes(size = p_size), data = p$plot_data %>%
               filter(p_adj < 0.05, as.character(row) != as.character(col)),
             shape = "*") +
  scale_size(range = c(4, 8)) +
  labs(size = "-log10(p_adj)")
```

```{r}
p <- ggcorrhm(mtcars, p_values = TRUE, p_thresholds = NULL,
              p_adjust = "bonferroni", return_data = TRUE,
              layout = "tl", include_diag = FALSE)
ggcorrhm(mtcars, layout = "tl", include_diag = FALSE) +
  geom_point(data = p$plot_data %>%
               filter(p_adj >= 0.05 , as.character(row) != as.character(col)),
             shape = 4, size = 8)
```


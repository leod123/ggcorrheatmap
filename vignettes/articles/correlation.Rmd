---
title: "Correlation heatmaps"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(ggcorrheatmap)
library(ggplot2)
library(dplyr)
```

Correlation heatmaps can be made easily using the `ggcorrhm` function. `ggcorrhm` is a wrapper for (and shares most of its arguments with) `gghm` and calculates the correlation matrix for the input passed to `gghm`. If one matrix is provided the column-column correlations are plotted. If two matrices are provided, the correlations between the columns in the two matrices are plotted. Using the `cor_method` and `cor_use` different `method` and `use` arguments can be passed to `stats::cor`.

```{r symmetric correlation heatmap}
ggcorrhm(mtcars)
```

```{r asymmetric correlation heatmap, fig.height=3, fig.width=8}
ggcorrhm(iris[1:nrow(mtcars), -5], mtcars)
```

# Changing the colours

`ggcorrhm` sets the fill scale to use `ggplot2::scale_fill_gradient2()` with limits set to [-1, 1]. The colours can be changed using the `high`, `mid` and `low` arguments. If a discrete scale is desired, `bins` can be used to bin the scale. The scale can be overwritten completely by adding a `ggplot2` scale to the plot.

For symmetric matrices, the axis names are drawn on the diagonal. The `names_diag`, `names_x` and `names_y` arguments control where names should be drawn.

```{r changing colour, out.width='50%', fig.show='hold'}
ggcorrhm(mtcars, names_diag = FALSE, names_x = TRUE, names_y = TRUE,
         high = "green", low = "magenta", mid = "yellow", bins = 6)

ggcorrhm(mtcars) + scale_fill_continuous()
```

# Changing the layout

For symmetric heatmaps, the `layout` argument can be used to get triangular layouts. The possible layouts are full matrix (the default), top left, top right, bottom left, and bottom right. EXPLAIN HOW IT WORKS, ALSO MAYBE REWORK TO ADD NEGATION OF TOP/UP/RIGHT.

```{r heatmap layouts}
ggcorrhm(mtcars, layout = "topleft")
# The diagonal is hidden by default but can be displayed using the `include_diag` argument
ggcorrhm(mtcars, layout = "br", include_diag = TRUE)
```

# Label customisation

The looks of the names displayed in the diagonal of symmetric matrices can be adjusted with the `names_diag_params` argument, which takes a named list of parameters to pass to `ggplot2::geom_text`. For names displayed on the x and y axes, use `ggplot2::theme` on the generated plot object to change the appearance.

```{r, fig.width=5, fig.height=4, fig.show='hold', out.width='50%'}
ggcorrhm(mtcars, layout = "bl", show_legend = FALSE, names_diag_param = list(
  angle = 45, vjust = 0.5, hjust = 0.5, colour = "magenta"
))
# Also take vectorised input
set.seed(123)
ggcorrhm(mtcars, layout = "br", names_diag_param = list(
  angle = c(0, rep(-45, 9), 90),
  hjust = c(rep(0.7, 10), 0.3),
  colour = sample(c("red", "green", "blue"), 11, TRUE)
))
```

# Legend position

The legend can be moved around by adding to the theme of the output plot using `ggplot2::theme`. Use the `legend.position.inside` argument to move the legend to the plotting area to make use of the empty space of triangular layouts.

```{r legend position, fig.width=5, fig.height=4, fig.show='hold', out.width='50%'}
ggcorrhm(mtcars) + theme(legend.position = "top")
ggcorrhm(mtcars, layout = "br") +
  theme(legend.position = "inside", legend.position.inside = c(0.2, 0.7))
```

# Clustering and annotation

Just like with `gghm`, the heatmap can be clustered and annotated. Triangular layouts limit the positions of annotation and dendrograms to the non-empty sides of the heatmap.

```{r clustering and annotation}
set.seed(123)
# Make a correlation heatmap with a triangular layout, annotations and clustering
row_annot <- data.frame(.names = colnames(mtcars),
                        annot1 = sample(letters[1:3], ncol(mtcars), TRUE),
                        annot2 = rnorm(ncol(mtcars)))
ggcorrhm(mtcars, layout = "tl", cluster_rows = TRUE, cluster_cols = TRUE,
         dend_rows = FALSE, annot_rows_df = row_annot, annot_rows_label_side = "top")
```

# Cell shape

Correlation heatmaps are sometimes plotted with circles. Using the `cell_shape` argument allows for custom cell shapes. The shape size is set to scale with the absolute value of the correlation. `size_scale` can be provided to overwrite this behaviour. 

```{r cell shape, fig.show='hold', out.width='50%'}
# If numeric, the R pch symbols are used, meaning 21 produces circles.
# Any character value results in normal heatmap cells
ggcorrhm(mtcars, cell_shape = 21) + labs(title = "cell_shape = 21")
# It is also possible to use shapes other than circles. Only 21-25 support filling.
# Change the size range using the size_range argument
ggcorrhm(mtcars, cell_shape = 23, size_range = c(1, 15)) +
  labs(title = "cell_shape = 23")
```

# Cell text

The `label_cor` argument labels cells with the values. The `cell_label_size` and `cell_label_digits` arguments control the text size and the number of displayed digits, respectively.

```{r cell labels}
ggcorrhm(mtcars, layout = "br", label_cor = TRUE)
```

# P-values

P-values can be calculated by setting the `p_values` argument to `TRUE`. The values can be adjusted for multiple testing by passing a string specifying the adjustment method to `p_adjust`. If the correlation matrix is symmetric, the diagonal is excluded and only half of the off-diagonal values are used for the adjustment. The calculated p-values will be included in the data if `return_data` is `TRUE`.

By default, cells are marked with asterisks if `p_values` is `TRUE`. The `p_thresholds` argument controls the p-value thresholds. `p_thresholds` must be a named numeric vector where the values specify the thresholds (in ascending order) and the names are the symbols to use when a p-value is below those thresholds. `stats::symnum` is used to convert p-values and the last value of `p_thresholds` must be 1 (or any higher number) to set the upper bound. By default, `p_thresholds` is set to be `c("***" = 0.001, "**" = 0.01, "*" = 0.05", 1)`. As can be seen, 1 is left unnamed so that any p-values between 0.05 and 1 are unmarked.

If `label_cor` is `TRUE` (so that correlation values are written in the cells), the symbols from `p_thresholds` are added at the end of the correlation values.

```{r, fig.show='hold', out.width='33%'}
# P-value symbols added to the plot
ggcorrhm(mtcars, p_values = TRUE, p_adjust = "bonferroni", cell_label_size = 6)
# With correlation text
ggcorrhm(mtcars, p_values = TRUE, p_adjust = "bonferroni", label_cor = TRUE)
# Changing the symbols
ggcorrhm(mtcars, p_values = TRUE, p_adjust = "bonferroni",
         p_thresholds = c("+" = 0.01, "*" = 0.05, "ns" = 1))
```

By returning the data and using `ggplot2` functions it is possible to be more creative with the p-value marking than `ggcorrhm` allows out of the box.

```{r}
p <- ggcorrhm(mtcars, p_values = TRUE, p_thresholds = NULL,
              p_adjust = "bonferroni", return_data = TRUE,
              layout = "br", include_diag = TRUE)
p$plot_data <- mutate(p$plot_data,
                      p_lty = case_when(p_adj < 0.05 ~ 1, T ~ 3),
                      p_lwd = case_when(p_adj < 0.05 ~ 1, T ~ 0.5),
                      p_size = -log10(p_adj))
ggcorrhm(mtcars, border_lty = p$plot_data$p_lty, border_lwd = p$plot_data$p_lwd,
         layout = "br", include_diag = TRUE) +
  geom_point(aes(size = p_size), data = p$plot_data %>%
               filter(p_adj < 0.05, as.character(row) != as.character(col)),
             shape = "*") +
  scale_size(range = c(4, 8)) +
  labs(size = "-log10(p_adj)")
```


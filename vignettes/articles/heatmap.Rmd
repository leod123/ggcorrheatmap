---
title: "Making a heatmap"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

The `gghm` function can be used to make a heatmap from a matrix of data frame. Rows and columns are ordered the same way as in the input.

```{r setup}
library(ggcorrheatmap)
library(ggplot2)
suppressPackageStartupMessages(library(dplyr))
```


```{r heatmap}
gghm(mtcars)
```

The `ggcorrhm` function uses `gghm` to build a correlation heatmap. The correlations between the columns in the input are computed and plotted.

If the matrix being plotted is symmetric (as such a correlation matrix is), the axis labels are drawn on the diagonal. This behaviour can be changed using the `names_diag`, `names_x` and `names_y` arguments. A symmetric heatmap can also be plotted using triangular layouts, explained more in the [correlation matrix](correlation.html) vignette.

```{r correlation heatmap}
ggcorrhm(mtcars)
```

# Specifying colours

The colours of the heatmap can be adjusted by passing a `ggplot2::scale_fill_*` function call to the `fill_scale` argument.

```{r}
gghm(mtcars, fill_scale = scale_fill_viridis_c())

# Heatmap with discrete values
# Border colour and linewidth can be changed using the `border_col` and `border_lwd` arguments
set.seed(123)
gghm(replicate(15, sample(letters[1:3], 15, TRUE)),
     fill_scale = scale_fill_brewer(palette = "Pastel2"),
     border_col = "thistle1", border_lwd = 1)
```

# Cell borders

Cell borders are by default grey, but can be removed by setting `border_col` or `border_lwd` to NA or `border_lty` to 0 (if `cell_shape` is non-numeric, explained more in [correlation heatmaps](correlation.html#cell-shape)) or `border_lwd` to 0 (if `cell_shape` is numeric).

```{r}
# Use the volcano data
# It contains many rows and columns making the axes hard to read.
# Can either turn off labels with `names_x` and `names_y`, or use
# ggplot2::scale_x/y_discrete to change the labels
# (keep in mind that the y label order is reversed in the default layout and that overwriting the scale can change the label positions)
gghm(volcano, fill_scale = scale_fill_viridis_c(), border_col = NA,
     names_x = FALSE, names_y = FALSE)
```

`border_col`, `border_lwd`, and `border_lty` can take either values of length 1 or the same length as the input data. Using the `return_data` argument to get the plotting data makes it easier to implement conditional customisation of borders.

```{r, fig.show='hold', out.width='50%'}
# Single values as input
gghm(cor(mtcars), fill_scale = scale_fill_viridis_b(option = "mako"),
     border_col = "orange", border_lwd = 1, border_lty = 2)

# Two-step approach:
# - Make a plot with the data of interest, retrieve the plotting data
# - Make col, lwd, lty vectors based on some condition in the plotting data and pass to gghm
plt_dat <- gghm(cor(mtcars), return_data = TRUE)$plot_data
plt_dat <- mutate(plt_dat,
                  # The plotting data contains the columns 'row', 'col', and 'value', so avoid those names
                  colr = case_when(row == "hp" ~ "red", col == "vs" ~ "brown", T ~ "grey"),
                  lwd = case_when(row == "hp" | col == "vs" ~ 1.5, T ~ 0.5),
                  lty = case_when(value > 0.5 ~ 1, T ~ 2))
gghm(cor(mtcars), fill_scale = scale_fill_viridis_b(option = "mako"),
     border_col = plt_dat$colr, border_lwd = plt_dat$lwd, border_lty = plt_dat$lty)
```

# Handling NAs

NAs in the data can be removed or set to a specific colour using the `na_remove` argument or the `fill_scale`argument, respectively. Setting `na_remove` to `TRUE` removes NAs from the plot (if a row or column is all NAs it will be dropped), but they can still interfere with clustering.

```{r, fig.width=4, fig.height=5, fig.show='hold', out.width='33%'}
# Introduce NAs
df_na <- as.matrix(mtcars)
set.seed(123)
df_na[sample(length(df_na), 100)] <- NA

# With NAs and the default colour
gghm(df_na, show_legend = FALSE) + labs(title = "With NAs")
# Colour NAs using scale function
gghm(df_na, show_legend = FALSE,
     fill_scale = scale_fill_continuous(na.value = "magenta")) +
  labs(title = "Change NA colour")
# Remove NAs, removes the border as well
gghm(df_na, show_legend = FALSE, na_remove = TRUE) + labs(title = "NAs removed")
```

# Clustering and annotation

Clustering can be applied to the rows and columns using the `cluster_rows` and `cluster_cols` arguments. See the [clustering](cluster.html) vignette for more on clustering.

```{r clustering}
gghm(scale(mtcars), cluster_rows = TRUE, cluster_cols = TRUE)
```

Row and column annotation is added by providing data frames to the `annot_rows_df` and `annot_cols_df` arguments. More details on annotation can be found in the [annotation](annotation.html) vignette.

```{r annotation}
row_annot <- data.frame(.names = rownames(mtcars),
                        a = sample(letters[1:4], nrow(mtcars), TRUE))

gghm(mtcars, annot_rows_df = row_annot)
```

Clustering and annotation can of course be added simultaneously.

```{r}
gghm(scale(mtcars), cluster_rows = TRUE, annot_rows_df = row_annot)
```

# External customisation

The plotting data can be returned by setting the `return_data` argument to `TRUE`, allowing for further customisation of e.g. cell labels.

```{r, fig.show='hold', out.width='50%', fig.width=4, fig.height=5}
plot_list <- gghm(scale(mtcars[, 1:10]), return_data = TRUE, border_col = NA,
                  fill_scale = scale_fill_gradient2(low = "deepskyblue", mid = "white", high = "salmon"))

# Add own labels
plot_list$plot_data$lab <- sample(letters[1:6], nrow(plot_list$plot_data), TRUE)

plot_list$plot +
  geom_text(aes(label = lab), plot_list$plot_data, size = 3)

# Or maybe points
plot_list$plot_data$lab <- ifelse(plot_list$plot_data$value > 1 |
                                  plot_list$plot_data$value < -1, "*", NA)
plot_list$plot +
  geom_point(data = subset(plot_list$plot_data, !is.na(lab)), shape = "*", size = 4)
```

There are many arguments, allowing for quite some flexibility in the heatmap layout. Most of the arguments are showcased in the vignettes, hopefully they can be of some help.

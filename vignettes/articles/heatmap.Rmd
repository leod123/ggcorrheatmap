---
title: "Making a heatmap"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

The `gghm` function can be used to make a heatmap from a matrix of data frame. Rows and columns are ordered the same way as in the input.

```{r setup}
library(ggcorrheatmap)
library(ggplot2)
suppressPackageStartupMessages(library(dplyr))
```


```{r heatmap}
gghm(mtcars)
```

The `ggcorrhm` function uses `gghm` to build a correlation heatmap. The correlations between the columns in the input are computed and plotted.

If the matrix being plotted is symmetric (as such a correlation matrix is), the axis labels are drawn on the diagonal. This behaviour can be changed using the `names_diag`, `names_x` and `names_y` arguments. A symmetric heatmap can also be plotted using triangular and mixed triangular layouts, explained more in the [correlation matrix](correlation.html) and [mixed layouts](mixed.html) vignettes.

```{r correlation heatmap}
ggcorrhm(mtcars)
```

# Specifying colours

The colours of the heatmap can be adjusted by passing a `ggplot2::scale_fill_*` function call to the `fill_scale` argument.

```{r}
gghm(mtcars, fill_scale = scale_fill_viridis_c())

# Heatmap with discrete values
# Border colour and linewidth can be changed using the `border_col` and `border_lwd` arguments
set.seed(123)
gghm(replicate(15, sample(letters[1:3], 15, TRUE)),
     fill_scale = scale_fill_brewer(palette = "Pastel2"),
     border_col = "thistle1", border_lwd = 1)
```

# Plotting modes

The `mode` argument takes a string and determines how the values will be plotted. 'heatmap' or 'hm' gives the default heatmap, 'text' results in the values being written out (the colour scaling with the cell value, specified by the `col_scale` argument), and any number from 1 to 25 changes the cells to the corresponding shapes (pch). There is also a 'none' mode which draws empty tiles (used internally by `ggcorrhm`).

Aside from the text mode, cells can be labelled with their values by setting `cell_labels` to `TRUE`. Unlike the text in text mode, cell label colours do not scale with the cell values. If cell labels are added to text mode the labels will be drawn on top (obscuring the colours and making the legend useless).

```{r}
gghm(mtcars[1:15, ], mode = "text")
gghm(mtcars[1:15, ], mode = 8)
gghm(mtcars[1:15, ], mode = "none")
```

# Cell borders

Cell borders are by default grey, but can be removed by setting `border_col` (border colour) or `border_lwd` (border linewidth) to NA or `border_lty` (border linetype) to 0 (if `mode` is non-numeric) or `border_lwd` to 0 (if `mode` is numeric).

```{r}
# Use the volcano data
# It contains many rows and columns making the axes hard to read.
# Can either turn off labels with `names_x` and `names_y`, or use
# ggplot2::scale_x/y_discrete to change the labels
# (keep in mind that the y label order is reversed in the default layout and that overwriting the scale can change the label positions)
gghm(volcano, fill_scale = scale_fill_viridis_c(), border_col = NA,
     names_x = FALSE, names_y = FALSE)
```

`border_col`, `border_lwd`, and `border_lty` can take either values of length 1 or the same length as the input data. Using the `return_data` argument to get the plotting data makes it easier to implement conditional customisation of borders.

```{r, fig.show='hold', out.width='50%'}
# Single values as input
gghm(cor(mtcars), fill_scale = scale_fill_viridis_b(option = "mako"),
     border_col = "orange", border_lwd = 1, border_lty = 2)

# Two-step approach:
# - Make a plot with the data of interest, retrieve the plotting data
# - Make col, lwd, lty vectors based on some condition in the plotting data and pass to gghm
plt_dat <- gghm(cor(mtcars), return_data = TRUE)$plot_data
plt_dat <- mutate(plt_dat,
                  # The plotting data contains the columns 'row', 'col', and 'value', so avoid those names
                  colr = case_when(row == "hp" ~ "red", col == "vs" ~ "brown", TRUE ~ "grey"),
                  lwd = case_when(row == "hp" | col == "vs" ~ 1.5, TRUE ~ 0.5),
                  lty = case_when(value > 0.5 ~ 1, TRUE ~ 2))
gghm(cor(mtcars), fill_scale = scale_fill_viridis_b(option = "mako"),
     border_col = plt_dat$colr, border_lwd = plt_dat$lwd, border_lty = plt_dat$lty)
```

# Handling NAs

NAs in the data can be removed or set to a specific colour using the `na_remove` argument or the `fill_scale`argument, respectively. Setting `na_remove` to `TRUE` removes NAs from the plot (if a row or column is all NAs it will be dropped), but they can still interfere with clustering.

```{r, fig.width=4, fig.height=5, fig.show='hold', out.width='33%'}
# Introduce NAs
df_na <- as.matrix(mtcars)
set.seed(123)
df_na[sample(length(df_na), 100)] <- NA

# With NAs and the default colour
gghm(df_na, show_legend = FALSE) + labs(title = "With NAs")
# Colour NAs using scale function
gghm(df_na, show_legend = FALSE,
     fill_scale = scale_fill_continuous(na.value = "magenta")) +
  labs(title = "Change NA colour")
# Remove NAs, removes the border as well
gghm(df_na, show_legend = FALSE, na_remove = TRUE) + labs(title = "NAs removed")
```

# Clustering and annotation

Clustering can be applied to the rows and columns using the `cluster_rows` and `cluster_cols` arguments. See the [clustering](cluster.html) vignette for more on clustering.

```{r clustering}
gghm(scale(mtcars), cluster_rows = TRUE, cluster_cols = TRUE)
```

Row and column annotation is added by providing data frames to the `annot_rows_df` and `annot_cols_df` arguments. More details on annotation can be found in the [annotation](annotation.html) vignette.

```{r annotation}
row_annot <- data.frame(.names = rownames(mtcars),
                        a = sample(letters[1:4], nrow(mtcars), TRUE))

gghm(mtcars, annot_rows_df = row_annot)
```

Clustering and annotation can of course be added simultaneously.

```{r}
gghm(scale(mtcars), cluster_rows = TRUE, annot_rows_df = row_annot)
```

# External customisation

The plotting data can be returned by setting the `return_data` argument to `TRUE`, allowing for further customisation of e.g. cell labels.

```{r, fig.show='hold', out.width='50%', fig.width=4, fig.height=5}
plot_list <- gghm(scale(mtcars[, 1:10]), return_data = TRUE, border_col = NA,
                  fill_scale = scale_fill_gradient2(low = "deepskyblue", mid = "white", high = "salmon"))

# Add own labels
plot_list$plot_data$lab <- sample(1:3, nrow(plot_list$plot_data), TRUE)

plot_list$plot +
  geom_text(aes(label = lab), plot_list$plot_data, size = 3)

# Or maybe points
plot_list$plot_data$lab <- ifelse(plot_list$plot_data$value > 1 |
                                  plot_list$plot_data$value < -1, "*", NA)
plot_list$plot +
  geom_point(data = subset(plot_list$plot_data, !is.na(lab)), shape = "*", size = 4)
```

There are many arguments, allowing for quite some flexibility in the heatmap layout. Most of the arguments are showcased in the vignettes, hopefully they can be of some help.

```{r}
gghm(cor(mtcars), mode = "none")
```


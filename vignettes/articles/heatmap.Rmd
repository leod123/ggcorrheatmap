---
title: "Making a heatmap"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

The `gghm` function can be used to make a heatmap from a matrix of data frame. Rows and columns are ordered the same way as in the input.

```{r setup}
library(ggcorrheatmap)
library(ggplot2)
suppressPackageStartupMessages(library(dplyr))
```


```{r heatmap, fig.alt='A heatmap of the mtcars data with a colour scale going from dark blue to blue.'}
gghm(mtcars)
```

The `ggcorrhm` function uses `gghm` to build a correlation heatmap. The correlations between the columns in the input are computed and plotted.

If the matrix being plotted is symmetric (as such a correlation matrix is), the axis labels are drawn on the diagonal. This behaviour can be changed using the `names_diag`, `names_x` and `names_y` arguments. A symmetric heatmap can also be plotted using triangular and mixed triangular layouts, explained more in the [correlation matrix](correlation.html) and [mixed layouts](mixed.html) vignettes.

```{r correlation heatmap, fig.alt='A symmetric heatmap showing the Pearson correlation between columns in the mtcars data. Colours range from blue (low) to red (high). The names of the variables are displayed on the diagonal.'}
ggcorrhm(mtcars)
```

# Specifying colours

The colours of the heatmap can be adjusted by passing a `ggplot2::scale_fill_*` function call to the `fill_scale` argument.

```{r, fig.alt='A heatmap of the whole mtcars data using the viridis colour scale.'}
gghm(mtcars, fill_scale = scale_fill_viridis_c())
```


```{r, fig.alt='A heatmap of a 15 by 15 matrix filled randomly with "a", "b", and "c". The Brewer Pastel2 palette is used for filling cells and the cell border colours have been changed to "thistle1".'}
# Heatmap with discrete values
# Border colour and linewidth can be changed using the `border_col` and `border_lwd` arguments
set.seed(123)
gghm(replicate(15, sample(letters[1:3], 15, TRUE)),
     fill_scale = scale_fill_brewer(palette = "Pastel2"),
     border_col = "thistle1", border_lwd = 1)
```

# Plotting modes

The `mode` argument takes a string and determines how the values will be plotted. 'heatmap' or 'hm' gives the default heatmap, 'text' results in the values being written out (the colour scaling with the cell value, specified by the `col_scale` argument), and any number from 1 to 25 changes the cells to the corresponding shapes (pch). There is also a 'none' mode which draws empty tiles (used internally by `ggcorrhm()`).

Aside from the text mode, cells can be labelled with their values by setting `cell_labels` to `TRUE`. Unlike the text in text mode, cell label colours do not scale with the cell values. If cell labels are added to text mode the labels will be drawn on top (obscuring the colours and making the legend useless).

```{r, fig.alt='A heatmap of the first 15 rows of the mtcars data, where the cells have the values written inside instead of being filled. The colour of the text scales with the value.'}
gghm(mtcars[1:15, ], mode = "text")
```


```{r, fig.alt='A heatmap of the first 15 rows of mtcars, where the cells have been substituted for stars (R pch 8). Both the size and colour scale with the value.'}
gghm(mtcars[1:15, ], mode = 8)
```


```{r, fig.alt='A heatmap of the first 15 rows of mtcars. The cells are not filled, leaving only emptiness within the cell borders.'}
gghm(mtcars[1:15, ], mode = "none")
```

# Cell borders

Cell borders are by default grey, but can be removed by setting `border_col` (border colour) or `border_lwd` (border linewidth) to NA or `border_lty` (border linetype) to 0 (if `mode` is non-numeric) or `border_lwd` to 0 (if `mode` is numeric).

```{r, fig.alt='A heatmap of the "volcano" R dataset using the viridis colour scale for filling cells. The cell borders have been removed.'}
# Use the volcano data
# It contains many rows and columns making the axes hard to read.
# Can either turn off labels with `names_x` and `names_y`, or use
# ggplot2::scale_x/y_discrete to change the labels
# (keep in mind that the y label order is reversed in the default layout and that overwriting the scale can change the label positions)
gghm(volcano, fill_scale = scale_fill_viridis_c(), border_col = NA,
     names_x = FALSE, names_y = FALSE)
```

`border_col`, `border_lwd`, and `border_lty` can take either values of length 1 or the same length as the input data. Using the `return_data` argument to get the plotting data makes it easier to implement conditional customisation of borders.

```{r, fig.show='hold', out.width='50%', fig.alt='Two correlation heatmaps of the mtcars data. Both use the viridis mako scale for filling cells. In the first plot the cell borders are thick, orange and dashed. In the second one, all cells where the row is "hp" are red and thick, cells wherer the column is "vs" are yellow and thick, and the rest are grey and thin. All cell borders are dashed.'}
# Single values as input
gghm(cor(mtcars), fill_scale = scale_fill_viridis_b(option = "mako"),
     border_col = "orange", border_lwd = 1, border_lty = 2)

# Two-step approach:
# - Make a plot with the data of interest, retrieve the plotting data
# - Make col, lwd, lty vectors based on some condition in the plotting data and pass to gghm
plt_dat <- gghm(cor(mtcars), return_data = TRUE)$plot_data
plt_dat <- mutate(plt_dat,
                  # The plotting data contains the columns 'row', 'col', and 'value', so avoid those names
                  colr = case_when(row == "hp" ~ "red", col == "vs" ~ "yellow", TRUE ~ "grey"),
                  lwd = case_when(row == "hp" | col == "vs" ~ 1.5, TRUE ~ 0.5),
                  lty = case_when(value > 0.5 ~ 1, TRUE ~ 2))
gghm(cor(mtcars), fill_scale = scale_fill_viridis_b(option = "mako"),
     border_col = plt_dat$colr, border_lwd = plt_dat$lwd, border_lty = plt_dat$lty)
```

# Handling NAs

NAs in the data can be removed or set to a specific colour using the `na_remove` argument or the `fill_scale`argument, respectively. Setting `na_remove` to `TRUE` removes NAs from the plot, but they can still interfere with clustering if a whole row or column is all NAs.

```{r, fig.width=4, fig.height=5, fig.show='hold', out.width='33%', fig.alt='Three heatmaps of the mtcars data. 100 random cells have been changed to NA. In the first plot the NA cells are grey, in the second they are magenta. In the last plot, NA cells are removed, leaving holes with no cell borders where there are NAs.'}
# Introduce NAs
df_na <- as.matrix(mtcars)
set.seed(123)
df_na[sample(length(df_na), 100)] <- NA

# With NAs and the default colour
gghm(df_na, show_legend = FALSE) + labs(title = "With NAs")
# Colour NAs using scale function
gghm(df_na, show_legend = FALSE,
     fill_scale = scale_fill_continuous(na.value = "magenta")) +
  labs(title = "Change NA colour")
# Remove NAs, removes the border as well
gghm(df_na, show_legend = FALSE, na_remove = TRUE) + labs(title = "NAs removed")
```

# Clustering and annotation

Clustering can be applied to the rows and columns using the `cluster_rows` and `cluster_cols` arguments. See the [clustering](cluster.html) vignette for more on clustering.

```{r clustering, fig.alt='A heatmap of mtcars, where rows and columns have been reordered according to hierarchical clustering results. Dendrograms are drawn to the right of and below the heatmap.'}
gghm(scale(mtcars), cluster_rows = TRUE, cluster_cols = TRUE)
```

Row and column annotation is added by providing data frames to the `annot_rows_df` and `annot_cols_df` arguments. More details on annotation can be found in the [annotation](annotation.html) vignette.

```{r annotation, fig.alt='Heatmap of mtcars with a thin column added to the right containing row annotation.'}
row_annot <- data.frame(.names = rownames(mtcars),
                        a = sample(letters[1:4], nrow(mtcars), TRUE))

gghm(mtcars, annot_rows_df = row_annot)
```

Clustering and annotation can of course be added simultaneously.

```{r, fig.alt='Heatmap of mtcars. The rows have been clustered and along the right side is an annotation column with a dendrogram on its right.'}
gghm(scale(mtcars), cluster_rows = TRUE, annot_rows_df = row_annot)
```

# External customisation

The plotting data can be returned by setting the `return_data` argument to `TRUE`, allowing for further customisation of e.g. cell labels by adding geoms to the finished plot as shown below.

As explained in the 'Cell borders' section, arguments where the values are passed on to `ggplot2::geom_*` functions can be vectors with one value per cell. The drawing order can get a bit confusing; for the full, top right and bottom left layouts the cells are drawn from the top left moving down each column; by contrast, for top left and bottom right layouts cells are drawn from the bottom left moving up each column (due to the y-axis levels being reversed). The rows are ordered in their drawing order in the data returned when `return_data` is `TRUE` so that can be used as a reference. However, in general, passing vectors to static aesthetics in `ggplot2` can become tricky and adding another geom to the output plot is more robust.

```{r, fig.show='hold', out.width='50%', fig.width=4, fig.height=5, fig.alt='Two heatmaps of z-scores of mtcars. The colours are changed to a divergent scale going from blue to red. The first plot has had its cells labelled randomly with 1s, 2s, and 3s. The second plot has asterisks in cells where the z-score is above 1 or below -1.'}
plot_list <- gghm(scale(mtcars[, 1:10]), return_data = TRUE, border_col = NA,
                  fill_scale = scale_fill_gradient2(low = "deepskyblue", mid = "white", high = "salmon"))

# Add own labels
plot_list$plot_data$lab <- sample(1:3, nrow(plot_list$plot_data), TRUE)

plot_list$plot +
  geom_text(aes(label = lab), plot_list$plot_data, size = 3)

# Or maybe points
plot_list$plot_data$lab <- ifelse(plot_list$plot_data$value > 1 |
                                  plot_list$plot_data$value < -1, "*", NA)
plot_list$plot +
  geom_point(data = subset(plot_list$plot_data, !is.na(lab)), shape = "*", size = 4)
```

There are many arguments, allowing for quite some flexibility in the heatmap layout. Most of the arguments are showcased in the vignettes, hopefully they can be of some help. They go more into making [correlation heatmaps](correlation.html), [clustering](clustering.html) and [annotation](annotation.html), and making [mixed layout heatmaps](mixed.html).

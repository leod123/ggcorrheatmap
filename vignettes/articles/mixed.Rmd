---
title: "Mixed layouts"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(ggcorrheatmap)
```

If the matrix is symmetric it is possible to plot mixed layouts by giving two triangles (opposite each other) to the `layout` argument. Two modes must be provided, the default modes being `heatmap` for the first element and `text` for the second. The first element of `layout` gets the diagonal (if it is drawn).

```{r, fig.show='hold', out.width='50%'}
ggcorrhm(mtcars, layout = c("tl", "br"))
ggcorrhm(mtcars, layout = c("tl", "br"), mode = c("21", "23"))
```

Since mixed layouts consist of two triangular layout heatmaps, clustering can only be applied if both rows and columns are clustered (like for the simple triangular layouts).

```{r}
ggcorrhm(mtcars, layout = c("tr", "bl"), cluster_rows = TRUE)
```

If `return_data` is `TRUE` there will be an extra column called `layout`, showing which triangle each cell belongs to.

```{r}
head(ggcorrhm(mtcars, layout = c("tl", "br"), return_data = TRUE)$plot_data)
```

When the layout is mixed, a few arguments can take vectors or lists of length two. If a vector, each element is applied to the whole corresponding triangle in `layout`. If a list is provided, the elements can be whatever values that would be applicable for non-mixed layouts, i.e. a single value to apply to the whole triangle, or a vector with one value for each cell. 

The arguments that work like this are `border_col`, `border_lwd`, `border_lty`, `cell_labels`, `cell_label_col`, `cell_label_size`, `cell_label_digits`, and (for `ggcorrhm`) `p_values` and `cell_label_p`.

```{r}
colr <- c("#70369D", "#59369D", "#4A44AB", "#486ED8", "#5B9892", "#79C314", "#C6DB28", "#FBDD2B", "#FEB30A", "#F56B08", "#E81416")

ggcorrhm(mtcars, layout = c("bl", "tr"), mode = c("none", "hm"),
         # One value for the whole heatmap (border linewidth)
         border_lwd = 1.5,
         # Length two vector, each value being used for the whole corresponding triangle
         border_lty = c(1, 3),
         # A list with values for each triangle
         border_col = list(
           # The first triangle is 66 values (if the diagonal is drawn), second 55
           # If not known, can return the plotting data to see how many cells are in each triangle
           # Since the matrix must be symmetric the numbers can also be calculated
           # Total: ncol*ncol, triangle without diagonal: (total - ncol) / 2, with diagonal: without + ncol
           # First triangle, provide all values, moving down each column from the left
           rev(unlist(sapply(seq_along(colr), function(i) rep(colr[i], i)))),
           # Second triangle, recycle one value
           "grey"
         ),
         # Also draw cell labels on the first triangle and set the same colours as the cells
         cell_labels = c(TRUE, FALSE),
         cell_label_col = list(
           # Provide the same values as for the cell border colours, but minus one as the diagonal
           # names are written instead of cell labels and are controlled differently
           rev(unlist(sapply(seq_along(colr), function(i) rep(colr[i], i - 1)))),
           1 # Anything as there are no labels
         ))
```

As mentioned above, p-values can be added to only one half of the heatmap if desired.

```{r}
ggcorrhm(mtcars, layout = c("tl", "br"), p_values = TRUE)
ggcorrhm(mtcars, layout = c("tl", "br"), p_values = c(FALSE, TRUE))
```

By using the `cell_label_p` argument, one triangle can be set to show correlation values and the other to show p-values.

```{r}
ggcorrhm(mtcars, layout = c("tr", "bl"), mode = c("hm", "hm"),
         p_values = c(FALSE, TRUE), cell_label_p = c(FALSE, TRUE),
         p_adjust = "bonferroni", cell_labels = TRUE)
```

Using mixed layouts with mode "none" it is possible to "hack" annotation and dendrograms onto the empty sides of the triangular layouts.

```{r}
annot <- data.frame(.names = colnames(mtcars), a = 1:11)
ggcorrhm(mtcars, layout = c("tl", "br"), mode = c("hm", "none"),
         annot_rows_df = annot, annot_cols_df = annot,
         cluster_rows = TRUE, cluster_cols = TRUE,
         # Hide cell borders only in the 'none' triangle
         border_lwd = c(0.5, 0))
```

